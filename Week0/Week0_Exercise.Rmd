---
title: "Week 0 Exercise: Introduction to Git, GitHub, and RStudio "
author: "Z620: Quantitative Biodiversity, Indiana University"
date: "January 6, 2017"
output: pdf_document
geometry: margin=2.54cm
---

## OVERVIEW

This exercise introduces some of the basics of the computing enviroment that we will be using in Quantitative Biodiversity.
By the end of the this exercise you will have a basic understanding of version control and how it is implemented using Git and GitHub, which which will require using the command line in shell of UNIX. Last, you will become acquainted with Rstuio and how to peform basic operation along with becoming familiar with how to work with vectors and matrices. 

##1) Version Control
Mismanaging changes to data, manuscripts, and computer code is one of the most dangerous things you can do as a scientist.
Yet, this is easily done when renaming and emailing files, when storing files in folders that get forgotten about or on drives that get lost or damaged, and when working in collaboration.
Naming a file "Dissertation-Project-StatsCode-Final-v23.R" and then emailing it between people is madness!
Funding agencies and many journals now require authors to provide well-managed data and can call on authors to provide proof of reproducibility.
Consequently, an increasing number of scientists, including those at CERN: <https://github.com/cernops> and NCBI: <https://github.com/ncbi>, are using an approach that has been used by tech companies for years, i.e., version control.

Version control is an approach to writing text, managing data, and developing computer code that allows users the ability to examine, comment on, and revert back to changes within the entire life of a document, and without being tied to any single computer.
In addition, multiple people in remote locations can collaborate on the same text, code, and data without emailing copies and without losing or overwriting any changes.
The individual graduate student can now step out of the stone age and professionally, cleanly, and safely manage all of their projects, while promoting their own research.
Yay for version control!

### How version control works, in a nutshell
In short, version control works by centralizing a project in a repository located on a server (e.g., a computer connected to the internet). 
The individual user never directly edits the code, data, or text in this online repository (a.k.a., **repo**).
Instead, the user makes changes to a local version of the project (e.g., on your laptop) and pushes those changes to the online version.
The history of the online version is tracked so the entire history of a project is protected.
Likewise, if the online version is directly changed or updated, e.g. by collaborators, then the user merely pulls in the changes from the online version.
All this pushing, pulling, and deciding how different versions from different computers get merged together is done by version control software.
In this class, we will use the most popular and powerful version control software and services out there, i.e. Git and GitHub.

### Git and GitHub
**Git** is a free and open-source version control system designed to handle projects of all sizes with speed and efficiency. 
Users install Git onto their local machines (e.g. laptop) but unlike some software you might be familiar with, such as internet browsers, Git *per se* does not have a graphical interface.
Instead, we will work with Git through your computer's terminal window (a.k.a., "shell")

**GitHub** is a web-based service for hosting projects that use the Git version control system.
GitHub provides an attractive interface for viewing and managing a project's code, data, and text files.
If your project is visible to others (public), then GitHub also serves as a way to let the world know about the awesome science you're doing and even how to join in and share tools.
While many companies, agencies, and governments use GitHub (<https://government.github.com/>), GitHub is a great central location to manage any project.


####Assignment 1:
Read PLOS computational biolology paper

####Assignment 2:
Create a GitHub account

####Assignment 3:
Go through the reading and tutorials here: http://www.ee.surrey.ac.uk/Teaching/Unix/



## 1) HOW WE WILL BE USING R AND OTHER TOOLS


--> What is R
--> RStudio uses R and is more user friendly
--> Also does some other things that we'll get to later. 

During the course, we will use RStudio (http://www.rstudio.com/), which is a user-friendly integrated developement environment (IDE) that allows R to interface with other tools. 
For example, the document you are reading was generated in RMarkdown (<http://rmarkdown.rstudio.com>). 
Markdown is a simple formatting syntax for authoring HTML, PDF, and other documents. 

We will also use a tool called knitr (http://yihui.name/knitr/), which is a package that generates reports from R script and Markdown text. 
For example, when you click the **Knit PDF** button in the scripting window of RStudio, a document will be generated that includes LaTeX (http://www.latex-project.org/) typesetting as well as the output of any embedded R code. 

However, if there are errors in the Rcode contained in your Markdown document, you will not be able to knit a PDF file. 
Assignments in this class will require that you successfully create a Markdown-generated PDF using knitr; you will then **push** this document to the course **respository** hosted on IU's GitHub (<https://github.iu.edu>) and generate a **pull request**.

## 2) SETTING YOUR WORKING DIRECTORY

https://rstudio.iu.edu

## 3) USING R AS A CALCULATOR

R is capable of performing various calcuations using simple operators and built-in **functions**

***Addition***:
```{r, results = 'hide'}
1 + 3 
```

***Subtraction***:
```{r, results = 'hide'}
3 - 1 
```

***Multiplication*** (with an exponent):
```{r, results = 'hide'}
3 * 10^2
```

***Division*** (using a built-in constant; pi):
```{r, results = 'hide'}
10 / pi 
```

***Trigonometry*** with a simple built-in function (i.e., *sin*) that takes an **argument** (i.e., '4'):
```{r, results = 'hide'}
sin(4) 
```

***Logarithms*** (another example of functions and arguments)
```{r, results = 'hide'}
log10(100)  # log base 10
log(100)    # log base e "natural log"  
```

## 4) ASSIGNING VARIABLES

You will often find it useful and necessary to assign values to a **variable**, also known as an **object** in R. 
Generally speaking, in R, it's best to use `<-` rather than `=` as an assignment operator.
```{r}
a <- 10
b <- a + 20
```

What is the value of `b`? 

Now let's reassign a new value to `a`:
```{r}
a <- 200
```

Now, what is the value of `b`? 
What's going on? 

R held onto the original value of `a` that was used when assigning values to `b`. 
You can correct this using the `rm` function, which removes objects from your R **environment**. 
```{r}
rm("b")
```

What happens if we reassign `b` now?
```{r}
b <- a + 20
```

Sometimes it's good practice to clear all variables from your R environment (e.g., you've been working on multiple projects during the day). 
This can be done in a couple of ways. 
For example, you can just click `clear` in the **Environment/History pane** window of R Studio. 
The same procedure can be performed at the **command line** in the Rstudio **Console pane** or **Script Editor pane**.
To do this, you can use the `ls` function to view a list of all the objects in the R environment:
```{r}
ls()
```

You can now clear all of the stored variables from R's memory using two functions: `rm` and `ls`. (Note: we did this above prior to setting our working directory).
```{r}
rm(list=ls())
```


## 5) WORKING WITH VECTORS
###Basic Features Of Vectors

**Vectors** are the fundamental data type in R. 
Often, vectors are just a collection of data of a similar type, either numeric (e.g., 17.5), integer (e.g., 2), or character (e.g., "low"). 
The simplest type of vector is a single value, sometimes referred to as a **scalar** in other programming languages:
```{r}
w <- 5 
```

We can create longer one-dimensional vectors in R like this: 
```{r}
x <- c(2, 3, 6, w, w + 7, 12, 14)
```

What is the function `c`() that we just used to create a vector? 
To answer this question, trying typing `help`() function at the command line. 
Let's try it out:
```{r, results = 'hide'}
help(c)
```

What happens when you multiply a vector by a "scalar"?
```{r}
y <- w * x
```

What happens when you multiply two vectors of the same length?
```{r}
z <- x * y 
```

You may need to reference a specific **element** in a vector. We will do this using the square brackets. 
In this case, the number inside of the square brackets tells R that we want call the *i*th element of vector `z`:
```{r}
z[2]
```

You can also reference **multiple elements** in a vector using the square brackets and the colon symbol:
```{r}
z[2:5] 
```

In some instances, you may want to change the value of an element in a vector. 
Here's how you can substitute a new value for the second element of `z`:
```{r}
z[2] <- 583 
```

###Summary Statictics of Vectors

It's pretty easy to perform summary statistics on a vector using the built-in fuctions of R:
```{r, results = 'hide'}
max(z)    # maximum
min(z)    # minimum
sum(z)    # sum
mean(z)   # mean
median(z) # median
var(z)    # variance
sd(z)     # standard deviation
```

What happens when you take the standard error of the mean (`sem`) of `z`? 

The standard error of the mean is defined as $\frac{sd (x)}{\sqrt{n}}$. 
This function does not exist in the base package of R. 
Therefore, you need to write your own function. 
Let's give it a try:

```{r}
sem <- function(x){
  sd(x)/sqrt(length(x))
  }
```

There are number of functions inside of `sem`. 
Take a moment to think about and describe what is going on here. 
Now, use the `sem` function you just created on the vector `y` from above

Often, datasets have missing values (designated as 'NA' in R):
```{r}
i <- c(2, 3, 9, NA, 120, 33, 7, 44.5)
```

What happens when you apply your `sem` function to vector `i`? This is a problem!

```{r}
sem <- function(x){
  sd(na.omit(x))/sqrt(length(na.omit(x))) 
  }
```
 
Now run `sem` on the vector `i`.

--- perhaps stop here?


## 5) WORKING WITH MATRICES

**Matrices** are another data type in R. 
They are just two-dimensional vectors containing data of the same type (e.g., numeric, integer, character). 
Thereofore, much of what we just discussed about vectors translates directly into dealing with matrices. 

### Making A Matrix

There are three common ways to create a matrix in R. 

**Approach 1** is to combine (or **concatenate**) two or more vectors. 
Let's start by creating a one-dimensional vector using a new function `rnorm` based on information contained in vector `z` above.
```{r}
j <- c(rnorm(length(z), mean = z)) 
```

**Q1:** What does the `rnorm` function do? What are the arguments specifying? 
Remember to use `help()` or type `?rnorm`.

Now we will use the function `cbind` to create a matrix from the two one-dimensional vectors:
```{r}
k <- cbind(z, j) 
```

Use the `help` function to learn about `cbind`.
Use the `dim` function to describe the matrix you just created. 

```{r, results = 'hide'}
dim(k) 
```

**Approach 2** to making a matrix is to use the `matrix` function along with arguments that specify the number of rows (`nrow`) and columns (`ncol`):

```{r}
l <- matrix(c(2, 4, 3, 1, 5, 7), nrow = 3, ncol = 2) 
```

**Approach 3** to making a matrix is to import or **load a dataset** from your working directory:

```{r}
m <- as.matrix(read.table("data/matrix.txt", sep = "\t", header = FALSE))
```

In this case, we're reading in a tab-delimited file. 
The name of your file must be in quotes, and you need to specify that it is a tab-delimited file type using the `sep` argument. 
The `header` argument tells R whether or not the names of the variables are contained in the first line; in the current example, they are not. 

Often, when handling datasets, we want to be able to **transpose** a matrix. This is an easy operation in R that uses the `t` function:
```{r}
n <- t(m)
```

**Q2:** What are the dimensions of the matrix you just transposed?

###Indexing a Matrix

Frequently, you will need to **index** or retrieve a certain portion of a matrix. 
As with the vector example above, we will use the square brackets to return data from a matrix. 
Inside the square brackets, there are now two subscripts corresponding to the rows and columns, respectively, of the matrix. 

The following code will create a new matrix (`n`) based on the first three rows of matrix (`m`):
```{r}
n <- m[1:3, ]
```

Or maybe you want the first two columns of a matrix instead:
```{r}
n <- m[, 1:2]
```

Or perhaps you want non-sequential columns of a matrix. 
How do we do that? 
It's easy when you understand how to reference data within a matrix:
```{r}
n <- m[, c(1:2, 5)]
```

**Q3:** Describe what we just did in the last indexing operation?

